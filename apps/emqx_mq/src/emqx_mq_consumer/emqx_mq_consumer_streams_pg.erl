%%--------------------------------------------------------------------
%% Copyright (c) 2025 EMQ Technologies Co., Ltd. All Rights Reserved.
%%--------------------------------------------------------------------

-module(emqx_mq_consumer_streams_pg).

-include("../emqx_mq_internal.hrl").
-include_lib("snabbkaffe/include/snabbkaffe.hrl").

-export([
    new/2,
    fetch_progress_updates/1,
    handle_ds_info/2,
    handle_ack/2,
    inspect/1
]).

-behaviour(gen_server).

-export([
    init/1,
    handle_continue/2,
    handle_call/3,
    handle_cast/2,
    handle_info/2,
    terminate/2
]).

% CREATE TABLE messages (
%     id BIGINT GENERATED BY DEFAULT AS IDENTITY,
%     topic TEXT NOT NULL,
%     created_at TIMESTAMPTZ NOT NULL,
%     message BYTEA NOT NULL,
%     transaction_id xid8 NOT NULL DEFAULT pg_current_xact_id(),

%     CONSTRAINT messages_pkey PRIMARY KEY (topic, transaction_id, id)
% );

-define(PG_SELECT_PREPARE_NAME, "select_mq_messages").
-define(PG_SELECT_PREPARE_QUERY, """
    SELECT id, message, transaction_id
    FROM messages
    WHERE
        topic = $1
        AND transaction_id > $2::xid8
        AND transaction_id < pg_snapshot_xmin(pg_current_snapshot())
    ORDER BY transaction_id, id ASC
    LIMIT $3
""").
-define(PG_SELECT_LIMIT, 100).

-define(SLAB, {<<"0">>, 1}).
-define(MESSAGE_ID(I), {?SLAB, I}).

-record(pg_messages, {
    messages = []
}).
-record(unblock, {}).
-record(inspect, {}).

-type t() :: #{
    reader_pid := pid(),
    unacked := #{non_neg_integer() => true}
}.

-export_type([t/0]).

new(MQ, _Progress) ->
    {ok, ReaderPid} = gen_server:start_link(?MODULE, [MQ, self()], []),
    #{reader_pid => ReaderPid, unacked => #{}, mq => MQ}.

handle_ds_info(#{unacked := Unacked0} = State, #pg_messages{messages = MessagesWithIds}) ->
    Unacked = lists:foldl(
        fun({MessageId, _Message}, UnackedAcc) ->
            UnackedAcc#{MessageId => true}
        end,
        Unacked0,
        MessagesWithIds
    ),
    {ok, MessagesWithIds, maybe_unblock(State#{unacked => Unacked})}.

handle_ack(#{unacked := Unacked0} = State, MessageId) ->
    Unacked = maps:remove(MessageId, Unacked0),
    maybe_unblock(State#{unacked => Unacked}).

fetch_progress_updates(State) ->
    {undefined, State}.

inspect(#{unacked := Unacked, reader_pid := ReaderPid} = _State) ->
    ReaderState = gen_server:call(ReaderPid, #inspect{}, infinity),
    ReaderState#{unacked => map_size(Unacked)}.

%%--------------------------------------------------------------------
%% Gen Server Callbacks (Reader)
%%--------------------------------------------------------------------

init([MQ, ConsumerPid]) ->
    {ok, Conn} = epgsql:connect(
        emqx_mq_message_db_pg:epgsql_opts(
            #{async => self()}
        )
    ),
    {ok, ReadStmt} = epgsql:parse(Conn, ?PG_SELECT_PREPARE_NAME, ?PG_SELECT_PREPARE_QUERY, []),
    ListenChannel = channel(MQ),
    {ok, _, _} = epgsql:squery(Conn, "LISTEN " ++ binary_to_list(ListenChannel)),
    State = #{
        mq => MQ,
        consumer_pid => ConsumerPid,
        connection => Conn,
        read_stmt => ReadStmt,
        has_data => true,
        blocked => false,
        last_id => 0,
        listen_channel => ListenChannel
    },
    ?tp_debug(mq_consumer_streams_pg_init, #{state => State}),
    {ok, State, {continue, fetch_data}}.

handle_continue(fetch_data, #{blocked := true} = State) ->
    {noreply, State};
handle_continue(fetch_data, #{has_data := false} = State) ->
    {noreply, State};
handle_continue(
    fetch_data,
    #{
        mq := #{topic_filter := TopicFilter} = _MQ,
        connection := Conn,
        read_stmt := ReadStmt,
        last_id := LastId
    } = State
) ->
    {ok, Cols, MessageRows} = epgsql:prepared_query(Conn, ReadStmt, [
        TopicFilter, integer_to_binary(LastId), ?PG_SELECT_LIMIT
    ]),

    Count = length(MessageRows),
    case Count of
        0 ->
            ?tp_debug(mq_consumer_streams_pg_fetch_data, #{messages => 0}),
            {noreply, State#{has_data => false}};
        N when N < ?PG_SELECT_LIMIT ->
            {Messages, NewLastId} = to_messages(State, Cols, MessageRows),
            send_messages(State, Messages),
            ?tp_debug(mq_consumer_streams_pg_fetch_data, #{messages => N, new_last_id => NewLastId}),
            {noreply, State#{has_data => false, blocked => true, last_id => NewLastId}};
        _N ->
            {Messages, NewLastId} = to_messages(State, Cols, MessageRows),
            send_messages(State, Messages),
            ?tp_debug(mq_consumer_streams_pg_fetch_data, #{messages => _N, new_last_id => NewLastId}),
            {noreply, State#{has_data => true, blocked => true, last_id => NewLastId}}
    end.

handle_info(#unblock{}, State) ->
    {noreply, State#{blocked => false}, {continue, fetch_data}};
handle_info(
    {epgsql, Connection, {notification, ListenChannel, _Pid, _Payload}},
    #{connection := Connection, listen_channel := ListenChannel} = State0
) ->
    ?tp_debug(mq_consumer_streams_pg_notification, #{payload => _Payload}),
    State = State0#{has_data => true},
    {noreply, State, {continue, fetch_data}};
handle_info(Info, State) ->
    ?tp(warning, mq_consumer_streams_pg_unknown_info, #{info => Info}),
    {noreply, State}.

handle_cast(Info, State) ->
    ?tp(warning, mq_consumer_streams_pg_unknown_cast, #{info => Info}),
    {noreply, State}.

handle_call(
    #inspect{}, _From, #{has_data := HasData, blocked := Blocked, last_id := LastId} = State
) ->
    {reply, #{has_data => HasData, blocked => Blocked, last_id => LastId}, State};
handle_call(Info, _From, State) ->
    ?tp(warning, mq_consumer_streams_pg_unknown_call, #{info => Info}),
    {reply, {error, {unknown_call, Info}}, State}.

terminate(_Reason, _State) ->
    ok.

%%--------------------------------------------------------------------
%% Internal functions
%%--------------------------------------------------------------------

to_messages(State, Cols, MessageRows) ->
    lists:mapfoldl(
        fun(MessageRow, _) ->
            parse_message(State, Cols, MessageRow)
        end,
        0,
        MessageRows
    ).

send_messages(#{consumer_pid := ConsumerPid} = _State, Messages) ->
    erlang:send(ConsumerPid, #pg_messages{messages = Messages}).

%% {Message, Id}
parse_message(_State, _Cols, {Id, MessageBin, TransactionId}) ->
    Message = emqx_mq_message_db:decode_message(MessageBin),
    IntTransactionId = binary_to_integer(TransactionId),
    {{?MESSAGE_ID({IntTransactionId, Id}), Message}, IntTransactionId}.

maybe_unblock(
    #{unacked := Unacked, reader_pid := ReaderPid, mq := #{stream_max_buffer_size := MaxUnacked}} =
        State
) ->
    case maps:size(Unacked) < MaxUnacked of
        true ->
            erlang:send(ReaderPid, #unblock{});
        false ->
            ok
    end,
    State.

channel(MQ) ->
    emqx_mq_message_db_pg:channel(MQ).
